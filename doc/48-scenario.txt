=======================================================================
The fixes have to support only mode "compile & run".

The precompile mode should continue to report on additional
definitions found after building the package.

We are only interested in adding more definitions, not in changes to
existing definitions.

=======================================================================
The basic scenario to support is, as far as I can tell:

(1) Edit a file foo.tcl with critcl command/proc definitions (A).

(2) Start an interactive tclsh
    (a) "source foo.tcl"
    (b) Run a command/procedure (A) defined by foo.tcl
        This implicitly compiles everything known from foo.tcl).

(3) Edit foo.tcl, add more command/proc definitions (B).

(4) In the still-running tclsh of step (2):
    (a) For a second time "source foo.tcl".
    (b) Run the new definition (B).
        This recompiles foo.tcl before executing B.

=======================================================================
Note: 
    Step 4a reads not only the new definitions, but the the already
    existing ones as well. And step 4b will recompile these also.

    In principle it is possible to change the existing definitions in
    step 3, and have these changes built into the new binary,
    overwriting the old definitions.

    If that is considered bad then critcl must keep enough information
    in the memory of the active tclsh to detect changes to existing
    definitions during 4b.

Note:
    critcl stores state (information about definitions, compile stuff)
    on a per-file basis, i.e. state for foo.tcl and bar.tcl are
    separate.

    Putting new definitions for foo.tcl into a separate file foo1.tcl
    should always be possible, as long as the new file has proper
    access to relevant type definitions at _compile_time_. Like
    external shared header files.

    Without such adding definitions is restricted to the same file,
    i.e. the scenario outlined above.

    And changes to data structures and existing definitions are then a
    bad idea, the C pieces already in memory will not match the
    changed things. So, detection of changes to previous definitions
    is likely a must-have to properly support this scenario. No sure
    how strong.  A simple reordering should be fine, as long as the
    result still compiles.

Note:
    All this stuff is something we do not need for precompile.

    => This should be in internal hook commands the precompile mode
       can modify, i.e. replace with no-ops, etc.

Note:
    The proposed critcl::reset, as is, has the following failure
    modes:

    (i)	As proposed the command must be run between steps 3 and 4a.
	If that is forgotten the current "AbortWhenCalledAfterBuild"
	will trap.

    (ii) Inappropriate use of critcl::reset can cause loss of data
	 when working with multiple critcl files. Example:

	 - Edit file foo.tcl, package foo.
	 - Edit file bar.tcl, package bar, independent of foo
	 - source foo.tcl, bar.tcl into a tclsh
	 - Run a command from foo, compiling foo.
	 - Edit foo.tcl
	 - critcl::reset
	 - Re-source foo.tcl
	 - Run the new command from foo, compiling foo
	 - Run a command from bar.
	   - Tries to compile bar.
	   - Find no data for bar, squashed by the critcl::reset.
	   - FAIL

	 Because the critcl::reset has squashed all the definitions
	 from bar.tcl.

========================================================================
Files for testing the changes

    foo1.tcl - Base file.
    foo2.tcl - foo1 + New definition.                 Accept.
    foo3.tcl - foo2, and changed ccode.               REJECT.
    foo4.tcl - foo2, and changed existing definition. REJECT.

foo1 -> foo2 is the scenario above we want to get working.

foo1 -> foo3 and
foo1 -> foo4 on the other hand are the cases where changes to the
existing declaratations of the file should be caught and cause the
reload to be rejected.

foo3 is the more difficult case because ccode blocks are not named. We
can only infer a possible change from an existing block going missing
and some new block appearing. It requires us to detect the beginning
of a reload, so that we can mark blocks as lost, and the end as well,
to check for still-marked blocks, for these are lost. During the
reload ccode blocks are either added as new, or found to exist already
and thus their lost-flag reset.

Note further, a reload of a file before it got compiled should simply
replace the entire set of declarations.

And a rejected reload should not change the internal data structures
at all, so that the next reload, after corrections can still suceed.


========================================================================
Action items:

- Add Hooks for
  (hs) Handle start 'source'ing a file (again)
  (he) Handle end of 'source'ing a file (again)
  (hd) Handle any decl after build.
  (hc) Handle post-compile activity.
  (h*) Handle pre/post-decl activity.

  - Precompile:
    hs:	no op

    he:	no op

    hd:	AbortWhenCalledAfterBuild

    hc:	Drop decls from memory after build, only keep main done flag

    h*:	no op

  - Compile & run:
    hs:	File not compiled at all => Drop existing decls. Full replace.
        Else mark (unnamed) ccode for lost-check.

    he:	Perform ccode lost-check, abort on lost ccode, rollback
	Advanced: Find most similar (content, location) new ccode?
		  Better/extended reporting?
	Allow lost ccode not marked as compiled.
	Allow lost cproc/cmd not marked as compiled.

    hd:	no op

    hc:	Keep decls (no op), per-decl compile marker set

    h*: Generate and store decl signature/hash,
	Compare if known.
	    Abort on changes. Rollback.
	    However, allow changed cproc/cmd not marked as compiled.
	Add unknown.

  - Rollback:
    Delete all decls which are not marked as compiled.

- Data structure changes
  - Per file
    - Marker is-compiled (Might already have it)
  - Per decl in file (named, unnamed)
    - Marker is-compiled
    - Marker is-lost
    - Hash value (signature) for change detection

- Document the internal data structures
  => DevGuide
